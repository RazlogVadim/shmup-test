В проекте используется DI-фреймворк Zenject. В его (проекта) основе лежит стейт машина, управляющая жизненным циклом игры.

Я попробовал разделить все на три сцены: стартовая (создает и запускает стейт машину), "карта" с уровнями и сам уровень.

В каждой сцене поначалу есть только Installer и Bootstrapper скрипты, которые, в свою очередь, пробрасывают зависимости и создают/инициализируют необходимые для сцены системы и объекты.

Объекты интерфейса создаются при помощи сервиса UIFactory, который получает нужные префабы, используя какой-нибудь IAssetLoader (в данном случае простая загрузка из Resources).

В <b>сцене карты</b> создается только View самой карты, который получает нужные данные об уровнях из сервиса LevelProgress.

В <b>сцене уровня</b> сервис AsteroidSpawner, используя пул объектов, отвечает за создание астероидов в соответствии с полученными из LevelProgress настройками текущего уровня (которые в свою очередь создаются LevelGenService'ом при завершении предыдущего уровня), а именно: цвет астероидов и частота создания. 
PlayerService создает объект игрока и следит за его состоянием. Скрипты движения и стрельбы игрока при помощи InputService получают данные о текущих инпутах. За создание снарядов отвечает сервис BulletSpawner, также использующий пул объектов. Вьюшка здоровья игрока создается в конце инициализации и подписывается на изменения здоровья игрока в PlayerService. 
Игра заканчивается, когда либо GameWinDecider в зависимости от IGameWinCondition завершит текущий уровень, либо здоровье игрока опустится до нуля. Следит за этим GameDirector, который в любом случае останавливает игру и создает окно завершения с соответствующим текстом.
У всех действующих объектов на сцене я попытался поделить скрипты по их функциям (View, Movement, TriggerDetection, etc.), при необходимости объединяя их в своебразном контроллере, который я назвал Brain.

Сохранение и загрузка данных происходят при помощи ProgressService. Сущности, нуждающиеся в сохранении/загрузке, наследуют от SaveProgressHandler, который регистрирует себя в ProgressService на этапе внедрения зависимостей. ProgressService может информировать все зарегистрированные объекты о загруженных данных, либо просить их обновить текущий прогресс, чтобы сохранить его при помощи IDataSaver - в данном случае простая JSON-сериализация и запись в PlayerPrefs.
